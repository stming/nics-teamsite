package nhk.ts.wcms.workflow;import java.io.BufferedInputStream;import java.io.ByteArrayInputStream;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.Hashtable;import java.util.List;import java.util.Map;import java.util.zip.CRC32;import java.util.zip.CheckedInputStream;import com.interwoven.cssdk.access.CSAuthorizationException;import com.interwoven.cssdk.access.CSExpiredSessionException;import com.interwoven.cssdk.common.CSClient;import com.interwoven.cssdk.common.CSException;import com.interwoven.cssdk.common.CSObjectNotFoundException;import com.interwoven.cssdk.common.CSRemoteException;import com.interwoven.cssdk.filesys.CSAreaRelativePath;import com.interwoven.cssdk.filesys.CSHole;import com.interwoven.cssdk.filesys.CSPathCommentPair;import com.interwoven.cssdk.filesys.CSPathStatus;import com.interwoven.cssdk.filesys.CSReadOnlyFileSystemException;import com.interwoven.cssdk.filesys.CSSimpleFile;import com.interwoven.cssdk.filesys.CSVPath;import com.interwoven.cssdk.filesys.CSWorkarea;import com.interwoven.cssdk.workflow.CSExternalTask;import com.interwoven.cssdk.workflow.CSURLExternalTask;import nhk.ts.wcms.common.Logger;import org.apache.commons.logging.LogFactory;/** * @author Arnout Cator Obfuscation URL external task implemented for Digital *         Asset Obfuscation in runtime LiveSite: Business Case: No digital *         asset can have a recognisable path in the customers web site. */public class ObfuscationDelete implements CSURLExternalTask {    /**     * Declare Instance Variables.     */    private static final long serialVersionUID = 1L;    /**     * Log4J field.     */    private Logger mLogger = new Logger(LogFactory.getLog("nhk.ts.wcms.workflow.ObfuscationDelete"));    /**     * MessageDigest field. Used for obfuscating file path and name     */    private MessageDigest md;    /**     * int B64_SIMPLE_STRING final constant.     */    private static final int B64_SIMPLE_STRING = 0;    /**     * int B64_NOT_PATH_AND_FILE_NAME final constant.     *     * If we send in /a/b/c/d/someFile.txt or /a/b/c/d/someFile then obfuscate     * someFile.txt or someFile only and return it prepended with /a/b/c/d/     * Similary if just the filename no path and extension then obfuscate that     * and return     */    private static final int B64_NOT_PATH_AND_FILE_NAME = 1;    /**     * int B64_PATH_AND_FILE_NAME final constant. If we send in     * /a/b/c/d/someFile.txt or /a/b/c/d/someFile then obfuscate     * /a/b/c/d/someFile.txt or /a/b/c/d/someFile only and return it     */    private static final int B64_PATH_AND_FILE_NAME = 2;    /**     * int B64_FILE_NAME_ONLY field final constant. If we send in     * /a/b/c/d/someFile.txt or /a/b/c/d/someFile then obfuscate someFile.txt or     * someFile only and return it     *     */    private static final int B64_FILE_NAME_ONLY = 3;    /**     * String file field. Holds workflow file     *     */    private String file;    /**     * String initDir field. Initial Directory in workarea root "tmp" used for     * creating temporary files for attachment to workflow and for OpenDeploy to     * deploy     */    private String initDir;    /**     * ArrayList to hold the obfuscated files for attaching to workflow.     */    private List<CSAreaRelativePath> arrayList;    /**     * An array of obfuscated files     */    private CSAreaRelativePath[] obfusFiles;    /**     * List holding dcrs     */    List dcrList = new ArrayList();    /**     * List holding sitepublisher files     */    List sitepubList = new ArrayList();    /**     * List holding other unaffected files like pdf,doc, xls     */    List otherList = new ArrayList();    /**     * List holding other html files     */    List htmlFilesList = new ArrayList();    /**     * Branch name     */    String branchName="";    /**     * Obfuscation Workarea     */    CSWorkarea obfuscationWorkarea;    private CSAreaRelativePath[] obfusDCRRelPathArray;    private CSAreaRelativePath[] imageObfusFilesArray;    private CSAreaRelativePath[] sitepubFilesArray;    private CSAreaRelativePath[] otherFilesArray;    private CSAreaRelativePath[] htmlFilesArray;    /**     * Simple File     */    CSSimpleFile simpleFile;    /**     * Constructor of the object.     *     * @return     */    public ObfuscationDelete() {        super();    }    /**     * execute method implemented from Interface URLExternalTask.     *     * @params CSClient client, CSExternalTask task, Hashtable params     * @throws CSException     */    public void execute(CSClient client, CSExternalTask task, Hashtable params)            throws CSException {        // Step 1. Instantiate a MessageDigest object for B64DigestEncoder        try {            md = MessageDigest.getInstance("SHA");        } catch (NoSuchAlgorithmException e) {            // TODO Auto-generated catch block            mLogger.createLogDebug("Error executing obfuscation: " + e.getMessage(), e);            throw new RuntimeException(e);        }        // Step 2. Instantiate an ArrayList object for obfuscated files        List list = Collections.synchronizedList(new ArrayList<CSAreaRelativePath>());        setArrayList(list);        CSAreaRelativePath[] files = task.getFiles();        // TODO make the following Array List for digital assets a DCT        ArrayList extList = new ArrayList();        extList.add("jpg");        extList.add("jpeg");        extList.add("gif");        extList.add("swf");        extList.add("png");        //extList.add("css");        extList.add("flv");		extList.add("pdf");		extList.add("tif");		extList.add("tiff");   		extList.add("zip");        // Step 2. Get the current workarea vpath from task        String waPath = getObfuscationWorkarea(task).getVPath().toString();        // Create the directory if it does not exist        branchName = task.getArea().getBranch().getName();        String assetDir = waPath + "/tmp/"+branchName;        File assetFolderStr = new File(assetDir);		if(!assetFolderStr.exists()) {			mLogger.createLogDebug("execute making directory:" + assetDir);			assetFolderStr.mkdirs();		}				task.addComment("Start Checking Obfuscation Path...");        // Step 3. Encode the attached files and delete it        for (int i = 0; i < files.length; i++) {        	        	mLogger.createLogDebug("Processing "+files[i].getName());            String thisExt = files[i].getExtension();            if (thisExt == null) {                thisExt = "";            }            String string = "/";            setFile(string + files[i].toString());            mLogger.createLogDebug("Kind =  " + task.getArea().getFile(files[i]).getKind());                        if (task.getArea().getFile(files[i]).getKind() == CSHole.KIND) {                if (extList.contains(thisExt.trim().toLowerCase())) {                	// Step 3b. just do the extensions of type digital images in extList                    try {                        mLogger.createLogDebug("This Extension within Loop: " + thisExt);                        String srcImgPath = files[i].toString();                                                String obfImgPath = b64DigestEncoder(client, task, string + files[i].toString(), 2);                        mLogger.createLogDebug("Source Image Path: " + srcImgPath);                        mLogger.createLogDebug("Obfuscated Image Path: " + obfImgPath);                                            } catch (NoSuchAlgorithmException ex) {                        mLogger.createLogDebug("Error in encoding algorithm:", ex);                    } catch (UnsupportedEncodingException ex) {                        mLogger.createLogDebug("Error in encoding which is unsupported:", ex);                    }                }            }        }        // Step 6. Switch to obfuscation workarea        setObfuscationWorkarea(task);        mLogger.createLogDebug("current workarea changed to: "                + task.getArea().getVPath().toString());        // Step 7. Attach Obfuscated Files to Task        mLogger.createLogDebug("attaching files from arrayList with size:"                + arrayList.size());        obfusFiles = new CSAreaRelativePath[arrayList.size()];        mLogger.createLogDebug("obfusFiles[] with size:" + obfusFiles.length);        imageObfusFilesArray = (CSAreaRelativePath[]) arrayList.toArray(obfusFiles);                mLogger.createLogDebug("imageObfusFilesArray[] with size:" + imageObfusFilesArray.length);        for(int i=0; i < imageObfusFilesArray.length; i++){        	mLogger.createLogDebug("imageObfusFilesArray["+i+"] = " + imageObfusFilesArray[i].toString());        }                try {            CSPathStatus[] imageStatusArray;            if (imageObfusFilesArray != null) {                //Digital assets to attach                imageStatusArray = task.attachFiles(imageObfusFilesArray);                for(int i=0; i < imageStatusArray.length; i++){                	mLogger.createLogDebug("imageStatusArray["+i+"] = " + imageStatusArray[i].getStatusMessage());                }            }        } catch (Exception e) {            mLogger.createLogDebug("Error executing obfuscation: " + e.getMessage(), e);        }        // Finally attached files        CSAreaRelativePath[] finallyAttachedFiles = task.getFiles();        mLogger.createLogDebug("The following " + finallyAttachedFiles.length + " files have been re-attached from obfuscation_wa.");        for (int j = 0; j < finallyAttachedFiles.length; j++) {            CSAreaRelativePath cSAreaRelativePath = finallyAttachedFiles[j];            mLogger.createLogDebug("File re-attached:" + task.getArea().getVPath().toString() + "/" + cSAreaRelativePath.getParentPath() + "/" + cSAreaRelativePath.getName());        }        // Step 8. Go to Deployment Task transition.        task.addComment("Finish and go to next task...");        String nextTransition = task.getTransitions()[0];        mLogger.createLogDebug("Moving to next transition name:" + nextTransition);        task.chooseTransition(nextTransition, "Image files have been obfuscated");    }    /**     * Gets the workarea holding obfuscated images and DCRs with obfuscated     * image paths     *     * @param task     * @return     * @throws CSAuthorizationException     * @throws CSObjectNotFoundException     * @throws CSExpiredSessionException     * @throws CSRemoteException     * @throws CSException     */    public CSWorkarea getObfuscationWorkarea(final CSExternalTask task)            throws CSAuthorizationException, CSObjectNotFoundException,            CSExpiredSessionException, CSRemoteException, CSException {        CSWorkarea[] allworkarea = task.getArea().getBranch().getWorkareas();        for (int w = 0; w < allworkarea.length; w++) {            if (allworkarea[w].getName().matches("obfuscation_wa")) {                obfuscationWorkarea = allworkarea[w];                return obfuscationWorkarea;            }        }        throw new CSException(CSException.FAILED_TO_GET_FILES_ON_TASK_ERR,                "No obufscation workarea found");    }    /**     * Sets the workarea holding obfuscated images and DCRs with obfuscated     * image paths     *     * @param task     * @return     * @throws CSAuthorizationException     * @throws CSObjectNotFoundException     * @throws CSExpiredSessionException     * @throws CSRemoteException     * @throws CSException     */    public CSWorkarea setObfuscationWorkarea(final CSExternalTask task)            throws CSAuthorizationException, CSObjectNotFoundException,            CSExpiredSessionException, CSRemoteException, CSException {        CSWorkarea[] allworkarea = task.getArea().getBranch().getWorkareas();        for (int w = 0; w < allworkarea.length; w++) {            if (allworkarea[w].getName().matches("obfuscation_wa")) {                obfuscationWorkarea = allworkarea[w];                task.setArea(obfuscationWorkarea);                return obfuscationWorkarea;            }        }        throw new CSException(CSException.FAILED_TO_GET_FILES_ON_TASK_ERR,                "No obufscation workarea found");    }    /*     * (private) Utility Methods     */    /**     * _b64Digest digest utility method.     *     * @param part     * @return String     * @throws UnsupportedEncodingException     */    private String _b64Digest(String part) throws UnsupportedEncodingException {/*        byte[] digest = getMd().digest(part.getBytes());        return new String(Base64.encode(digest)).replaceAll("\n", "").replaceAll("/", "").replaceAll("=", "").replaceAll("\\+", "");*/    			String crc32Version = "";		try{			crc32Version = Long.toString(createCRC32Checksum(part));		}catch(IOException e){			mLogger.createLogError("IOException", e);		}				return crc32Version;    }    /**     * b64DigestEncoder digest utility method.     *     * @param message     * @param type     * @return String     * @throws NoSuchAlgorithmException     * @throws UnsupportedEncodingException     */    private String b64DigestEncoder(CSClient client, CSExternalTask task, String message,            int type) throws NoSuchAlgorithmException,            UnsupportedEncodingException {        String retVal = null;        if (B64_SIMPLE_STRING == type) {            retVal = _b64Digest(message);        } else if (B64_NOT_PATH_AND_FILE_NAME == type) {            int lastSlash = message.lastIndexOf('/') > 0 ? message.lastIndexOf('/') : 0;            int lastDot = message.lastIndexOf('.');            String path = (lastSlash > 0 ? message.substring(0, lastSlash + 1)                    : "");            String fileName = (lastDot > 0 ? message.substring(                    lastSlash == 0 ? 0 : lastSlash + 1, lastDot) : message.substring(lastSlash == 0 ? 0 : lastSlash + 1));            String extension = (lastDot > 0 ? message.substring(lastDot) : "");            retVal = path + b64DigestEncoder(client, task, fileName) + extension;        } else if (B64_FILE_NAME_ONLY == type) {            int lastSlash = message.lastIndexOf('/') > 0 ? message.lastIndexOf('/') : 0;            int lastDot = message.lastIndexOf('.');            String fileName = (lastDot > 0 ? message.substring(                    lastSlash == 0 ? 0 : lastSlash + 1, lastDot) : message.substring(lastSlash == 0 ? 0 : lastSlash + 1));            String extension = (lastDot > 0 ? message.substring(lastDot) : "");            retVal = b64DigestEncoder(client, task, fileName) + extension;        } else if (B64_PATH_AND_FILE_NAME == type) {            mLogger.createLogDebug("in type 2: " + message);            String extension = null;            String theRest = message;            boolean startingSlash = message.charAt(0) == '/';            int dotPos = message.lastIndexOf(".");            if (dotPos > 0) {                extension = message.substring(dotPos);                theRest = message.substring(0, dotPos);                StringBuffer x = new StringBuffer();                String[] spl = theRest.split("/");                for (String enc : theRest.split("/")) {                    if (enc != null && !enc.equalsIgnoreCase("")) {                        String encodedStr = _b64Digest(enc);                        /*                        if (encodedStr.length() > 4) {                            encodedStr = encodedStr.substring(0, 3);                        }*/                        x.append(encodedStr);                        x.append("/");                    }                }                x.deleteCharAt(x.length() - 1);                retVal = getInitDir() + "/" +branchName + (startingSlash ? "/" : "")                        + (x.toString()) + (extension != null ? extension : "");            }        }        mLogger.createLogDebug("returned retval:  " + retVal);        try {            deleteObfuscatedFiles(client, task, file, retVal);        } catch (IOException e) {            mLogger.createLogDebug("Error executing obfuscation: " + e.getMessage(), e);        } catch (CSAuthorizationException e) {            mLogger.createLogDebug("Error executing obfuscation: " + e.getMessage(), e);        } catch (CSRemoteException e) {            mLogger.createLogDebug("Error executing obfuscation: " + e.getMessage(), e);        } catch (CSObjectNotFoundException e) {            mLogger.createLogDebug("Error executing obfuscation: " + e.getMessage(), e);        } catch (CSExpiredSessionException e) {            mLogger.createLogDebug("Error executing obfuscation: " + e.getMessage(), e);        } catch (CSException e) {            // TODO Auto-generated catch block            mLogger.createLogDebug("Error executing obfuscation: " + e.getMessage(), e);        }        return retVal;    }    /**     * b64DigestEncoder digest utility method.     *     * @param message     * @return String     * @throws NoSuchAlgorithmException     * @throws UnsupportedEncodingException     */    private String b64DigestEncoder(CSClient client, CSExternalTask task, String message)            throws NoSuchAlgorithmException, UnsupportedEncodingException {        return b64DigestEncoder(client, task, message, B64_SIMPLE_STRING);    }    /**     * Delete obfuscated files in temporary area.     *     * @param task     * @param origFile     * @param obfusFile     * @throws IOException     * @throws CSAuthorizationException     * @throws CSRemoteException     * @throws CSObjectNotFoundException     * @throws CSExpiredSessionException     * @throws CSException     * @return CSAreaRelativePath[] required by CSTask[] attachFiles     */    private void deleteObfuscatedFiles(CSClient client, CSExternalTask task, String origFile,            String obfusFile) throws IOException, CSAuthorizationException,            CSRemoteException, CSObjectNotFoundException,            CSExpiredSessionException, CSException {        String relDir = obfusFile;        int dirStart = relDir.lastIndexOf("/");        relDir = relDir.substring(0, dirStart);        CSAreaRelativePath origRelPath = new CSAreaRelativePath(origFile.substring(1));        CSAreaRelativePath obfusRelPath = new CSAreaRelativePath(obfusFile);        mLogger.createLogDebug("deleteObfuscatedFiles origRelPath: " + origRelPath);        mLogger.createLogDebug("deleteObfuscatedFiles obfusRelPath: " + obfusRelPath);        arrayList.add(obfusRelPath);        try {            mLogger.createLogDebug("deleteObfuscatedFiles Deleting " + obfusRelPath.toString());            CSAreaRelativePath[] currentFile = new CSAreaRelativePath[1];            currentFile[0] = obfusRelPath;                        //submit file in obfuscation area            CSPathCommentPair[] pathCommentPairs = new CSPathCommentPair[1];            pathCommentPairs[0] = new CSPathCommentPair(obfusRelPath, "");            getObfuscationWorkarea(task).submitDirect(null, null, pathCommentPairs, CSWorkarea.OVERWRITE_ALL);                        //delete file in obfuscation area            getObfuscationWorkarea(task).deleteFiles(currentFile);        } catch (CSAuthorizationException e) {            mLogger.createLogDebug("Error executing obfuscation: " + e.getMessage(), e);        } catch (CSObjectNotFoundException e) {            mLogger.createLogDebug("Error executing obfuscation: " + e.getMessage(), e);        } catch (CSExpiredSessionException e) {            mLogger.createLogDebug("Error executing obfuscation: " + e.getMessage(), e);        } catch (CSRemoteException e) {            mLogger.createLogDebug("Error executing obfuscation: " + e.getMessage(), e);        } catch (CSException e) {            mLogger.createLogDebug("Error executing obfuscation: " + e.getMessage(), e);        } catch (Exception e) {            mLogger.createLogDebug("Error executing obfuscation: " + e.getMessage(), e);        } finally {            System.gc();        }    }    /**     * deleteObfuscationWorkareaFiles     * @param task     * @param obfusDCRRelPathArray     * @param sitepubFilesArray     * @throws CSReadOnlyFileSystemException     * @throws CSRemoteException     * @throws CSExpiredSessionException     * @throws CSException     */    public void deleteObfuscationWorkareaFiles(CSExternalTask task, CSAreaRelativePath[] obfusDCRRelPathArray, CSAreaRelativePath[] sitepubFilesArray) throws CSReadOnlyFileSystemException, CSRemoteException, CSExpiredSessionException, CSException {        if (obfusDCRRelPathArray != null) {            //DCRs to attach            getObfuscationWorkarea(task).deleteFiles(obfusDCRRelPathArray);        }        if (sitepubFilesArray != null) {            //SitePublisher assets to attach            getObfuscationWorkarea(task).deleteFiles(sitepubFilesArray);        }    }    /*     * Getters and Setters     */    /**     * @param md     *            the md to set     */    public void setMd(MessageDigest md) {        this.md = md;    }    /**     * @return the md     */    public MessageDigest getMd() {        return md;    }    /**     * @return the file     */    public String getFile() {        return file;    }    /**     * @param file     *            the file to set     */    public void setFile(String file) {        this.file = file;    }    /**     * @return the initDir     */    public String getInitDir() {        this.initDir = "tmp";        return this.initDir;    }    /**     * @param initDir     *            the initDir to set     */    public void setInitDir(String initDir) {        this.initDir = initDir;    }    /**     * @param arrayList     *            the arrayList to set     */    public void setArrayList(List arrayList) {        this.arrayList = arrayList;    }    /**     * @return the arrayList     */    public List getArrayList() {        return arrayList;    }    /**     * @return the obfusFilesa     */    public CSAreaRelativePath[] getObfusFiles() {        return obfusFiles;    }    /**     * @param obfusFiles     *            the obfusFiles to set     */    public void setObfusFiles(CSAreaRelativePath[] obfusFiles) {        this.obfusFiles = obfusFiles;    }   	public long createCRC32Checksum(String input) throws IOException{				CheckedInputStream check;		InputStream is = new ByteArrayInputStream(input.getBytes("UTF-8"));		check = new CheckedInputStream(is, new CRC32());		BufferedInputStream in = new BufferedInputStream(check);		while (in.read() != -1) {			// Read file in completely		}		return check.getChecksum().getValue();	}    }